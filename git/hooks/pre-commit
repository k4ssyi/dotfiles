#!/usr/bin/env bash

# Pre-commit フック
# 静的解析（shellcheck）とシークレット検出を実行する
# common.sh は source しない（.git/hooks/ コンテキストでは ensure_dotfiles_root が失敗するため）

set -euo pipefail

# カラー定義
readonly RED='\033[31m'
readonly GREEN='\033[32m'
readonly YELLOW='\033[33m'
readonly CYAN='\033[36m'
readonly NC='\033[0m'

# 終了コード（両チェックを実行後にまとめて判定）
exit_code=0

print_header() {
    echo -e "${CYAN}── $1 ──${NC}"
}

print_pass() {
    echo -e "${GREEN}PASS${NC}: $1"
}

print_fail() {
    echo -e "${RED}FAIL${NC}: $1"
}

print_warn() {
    echo -e "${YELLOW}WARN${NC}: $1"
}

# --------------------------------------------------------------------------
# チェック1: shellcheck
# --------------------------------------------------------------------------
run_shellcheck() {
    print_header "shellcheck"

    # ステージ済み .sh ファイルを取得（追加・コピー・変更のみ）
    local staged_files
    staged_files=$(git diff --cached --name-only --diff-filter=ACM -- '*.sh')

    if [[ -z "$staged_files" ]]; then
        print_pass "対象の .sh ファイルなし"
        return
    fi

    if ! command -v shellcheck &>/dev/null; then
        print_warn "shellcheck が未インストールです（スキップ）"
        print_warn "  brew install shellcheck で導入できます"
        return
    fi

    local failed=0
    while IFS= read -r file; do
        if [[ ! -f "$file" ]]; then
            continue
        fi
        if ! shellcheck -x --exclude=SC1091,SC2088 "$file"; then
            failed=1
        fi
    done <<< "$staged_files"

    if [[ "$failed" -eq 1 ]]; then
        print_fail "shellcheck でエラーが検出されました"
        exit_code=1
    else
        print_pass "shellcheck"
    fi
}

# --------------------------------------------------------------------------
# チェック2: シークレット検出
# --------------------------------------------------------------------------
run_secrets_check() {
    print_header "secrets"

    # ステージ済みの追加行のみを検査
    local diff_output
    diff_output=$(git diff --cached -U0 || true)

    if [[ -z "$diff_output" ]]; then
        print_pass "差分なし"
        return
    fi

    # 追加行（+で始まる行）のみ抽出。ただし +++ ヘッダ行は除外
    local added_lines
    added_lines=$(echo "$diff_output" | grep '^+[^+]' || true)

    if [[ -z "$added_lines" ]]; then
        print_pass "追加行なし"
        return
    fi

    local found=0

    # 秘密鍵ヘッダ
    if echo "$added_lines" | grep -qE '-----BEGIN .* PRIVATE KEY-----'; then
        print_fail "秘密鍵が検出されました（PRIVATE KEY）"
        found=1
    fi

    # AWS アクセスキー
    if echo "$added_lines" | grep -qE 'AKIA[0-9A-Z]{16}'; then
        print_fail "AWS アクセスキーが検出されました"
        found=1
    fi

    # GitHub トークン
    if echo "$added_lines" | grep -qE 'gh[po]_[A-Za-z0-9_]{36,}'; then
        print_fail "GitHub トークンが検出されました"
        found=1
    fi

    # OpenAI / Anthropic API キー
    if echo "$added_lines" | grep -qE 'sk-[A-Za-z0-9]{20,}'; then
        print_fail "API キーが検出されました（sk-*）"
        found=1
    fi

    # password = / secret_key = に8文字以上の値
    if echo "$added_lines" | grep -qiE '(password|secret_key)\s*=\s*.{8,}'; then
        print_fail "パスワード/シークレットキーの代入が検出されました"
        found=1
    fi

    if [[ "$found" -eq 1 ]]; then
        echo ""
        print_fail "シークレットが検出されました。コミットをブロックします"
        echo -e "  バイパス: ${YELLOW}git commit --no-verify${NC}"
        exit_code=1
    else
        print_pass "secrets"
    fi
}

# --------------------------------------------------------------------------
# メイン
# --------------------------------------------------------------------------
echo ""
run_shellcheck
echo ""
run_secrets_check
echo ""

exit $exit_code
